# 02. 다형성을 사용하여 재사용성을 높인다.
> 그렇지 않으면 **같은 일을 하는 클래스임에도** 다루는 **객체 타입**이 다르다는 이유로 반복적으로 정의해야한다.

## 다형성 사용 전
### 배열의 한계
배열은 서로 같은 타입의 데이터들만 저장할 수 있다는 한계가 있다. 
즉, `Member` 객체와 `Board` 객체는 같은 배열에 저장할 수 없다. 
따라서 `Member[]`, `Board[]`을 따로 선언해 줘야하며, 각 객체를 다루는 메서드들 또한 반복적으로 정의해야 한다. 
결과적으로 아래 그림처럼 **데이터 타입 하나 당 `ArrayList` 클래스 하나**를 만들어야한다.  
![image](https://user-images.githubusercontent.com/68311318/148557195-1f7db53c-5e7a-43cd-b0c7-a9df3ba81257.png)  

```java
public class BoardArrayList {

    static final int DEFAULT_CAPACITY = 3;
    Board[] list;
    int size = 0;
    //...
}
```
```java
public class MemberArrayList {

    static final int DEFAULT_CAPACITY = 100;
    Member[] list;
    int size = 0;
    //...
}
```

즉, **같은 일을 하는 클래스임에도** 다루는 객체 타입이 다르다는 이유로 반복적으로 정의해야 하는 것이다. 이처럼 이기종 클래스들을 같은 레벨에서 다루게 되면 **단일한 관리**가 불가하여 일일이 다뤄주는 수 밖에 없다.

### 다형성을 사용하는 이유(이기종간 집합체의 탄생)
그래서 이기종 클래스들은 한 레벨 위에서 다뤄줘야 **단일한 관리**가 가능하다. 
즉, **부모 타입**의 배열을 사용해야 이기종 클래스들을 하나의 배열에 저장할 수 있다.  
이렇게 부모 타입의 배열에 저장한 이기종 클래스의 모임을 이기종간 집합체(Heterogeneous Collection)라고 한다.  
참고: Heterogeneous Collection의 반대는 Homogeneous Collection이다.  

## 다형성 사용 후
하나의 `ArrayList`클래스 만으로 여러 타입의 객체를 다룰 수 있다.

```java
public class ArrayList {
    static final int DEFAULT_CAPACITY = 3;
    Object[] list;
    int size = 0;
    //...
}
```

## 기타
### 1. 가상함수 호출(Virtual Method Invocation)  
오버라이딩을 하면 부모 객체와 자손 객체에 동일한 이름의 메소드가 있으므로 둘 중에 어떤 메소드를 호출해야할지 결정해야한다.  
**컴파일** 시점에는 참조변수 타입 클래스의 메소드가 호출되고  
**런타임** 시점에는 참조변수가 실제 참조하는 인스턴스의 메소드가 호출된다(실제 참조하는 인스턴스에 해당 이름의 메소드가 없다면 그 바로 위 부모 클래스의 메소드가 호출된다)  
**컴파일러**는 참조변수가 실제로 참조하는 인스턴스에 대해서는 전혀 알지 못하기 때문이다. 컴파일러는 참조변수의 타입만 신경쓸 뿐이다.

### 2. 타입 캐스팅  
상속관계에 있는 타입의 참조변수들은 서로 **캐스팅**이 가능하다. 사용할 멤버의 **개수**를 줄이고 늘리는 것을 **캐스팅**이라고 한다. 그러나 자손 타입의 참조변수가 부모 타입의 객체를 참조하는 것은 금지돼있다. 존재하지 않는 멤버를 사용하고자 할 가능성이 있기 때문이다.

### 3. instanceof 연산자를 사용하는 이유
**컴파일러**는 실행시 생성될 인스턴스의 타입에 대해서는 전혀 알지 못하기 때문에, 컴파일 에러가 발생하지 않았다고 그냥 지나친다면 런타임 에러를 마주칠 가능성이 있다. 따라서 우리는 항상 참조변수가 참조하고 있는 인스턴스의 실제 타입을 잘 파악해야 하며 그 때 사용하는 것이 `instanceof`이다. 