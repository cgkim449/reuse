# 04. 컬렉션 API를 사용하여 재사용성과 일관성을 높인다(인터페이스의 장점)
> 컬렉션 API는 컬렉션 사용 방법을 **표준화**했기 때문에 코드의 재사용성과 일관성을 높일 수 있는 것이다.

## 인터페이스의 장점 3가지

1. 표준화
    - 인터페이스는 **클래스 사용 방법**을 표준화하기 때문에 코드의 재사용성과 일관성을 높일 수 있다.
2. 독립적인 프로그래밍
    - 제일 중요한 장점. 그러나 의존성 주입과 결합해야만 가능하다. 의존성 주입에서 다루겠다.
3. 상속이 다중상속이 안되서 생기는 한계 극복
    -  상속은 다중 상속이 안되기때문에 '그 문제'를 해결할 수 없다.
        - 인터페이스는 상속 체계에 상관없이 클래스들을 추상화할 수 있다.

여기서는 **표준화**에 대해서만 다룬다.

## 표준화
컬렉션 API는 인터페이스와 다형성을 이용한 객체지향적 설계를 통해 표준화되어 있기 때문에 아래 코드와 같이 재사용성이 높은 코드를 작성할 수 있다는 장점이 있다.  
![Group 1](https://user-images.githubusercontent.com/68311318/148577707-2de96d80-4886-4ead-a25c-d4a36b29b7bd.png)  
이 코드에서 ArrayList가 아닌 다른 컬렉션 클래스(List 구현체)으로 교체하고 싶다면 `new ArrayList<>()`만 변경하면 된다. 그 외에 빨간 네모 안에 있는 코드는 변경하지 않아도 된다.    
Iterator를 이용해서 컬렉션의 요소를 읽어오는 방법을 **표준화**했기 때문에 빨간 네모 안의 코드를 전부 재사용하는 것이 가능한 것이다.
이처럼 인터페이스를 정의하여 클래스 사용 방법을 **표준화**함으로써 코드의 일관성을 유지하여 재사용성을 극대화하는 것이
객체지향 프로그래밍의 중요한 목적 중 하나이다.  

여기서 재사용성을 더 높이고자 하면 객체를 생성하는 코드(`new ArrayList<>()`) 도 없애야한다. 이는 의존성 주입으로 가능하다. 의존성 주입이 화룡점정인 것이다. 의존성 주입에서 다루도록 하겠다.

## 정리
인터페이스란 일종의 추상 클래스로, 오직 추상메서드와 상수만을 멤버로 가질 수 있기 때문에 추상 클래스보다 추상화 정도가 더 높다.  
인터페이스의 장점은 3가지로 정리할 수 있다.  
첫번째는, 인터페이스는 클래스 사용 방법을 표준화하였기 때문에 코드의 재사용성과 일관성을 높인다.  
두번째는, 인터페이스는 상속 체계와 전혀 무관하게 특정 클래스를 한번 더 추상화할 수 있다.  
세번째는, 독립적인 프로그래밍이 가능하다. 일단 인터페이스를 작성해 놓으면 그 인터페이스를 사용하는 클래스와 인터페이스 구현체는 독립적으로, 즉 동시에 작성할 수 있다. 그래서 개발시간이 단축된다.

## 기타
### 1. 컬렉션 프레임워크
컬렉션 프레임워크란, 컬렉션 클래스를 표준화한 것이다. 컬렉션 클래스란 컬렉션을 다루는 클래스이고, 컬렉션이란 다수의 데이터를 뜻한다.  

컬렉션 클래스는 Set, List, Map 중 하나에 속하게 된다. Set과 List의 부모는 Collection이다. Collection은 가장 원시적인 인터페이스이다. 데이터를 그냥 막 담는다. Set, List는 거기에서 각각 한 단계씩 발전했다. Set은 중복을 허용하지 않고, List는 저장 순서가 있다. Map은 데이터가 key-value 구조를 가지기 때문에, Collection의 상속계층도에 들어가고 싶어도 못들어갔다.  

컬렉션 클래스는 기본적으로 추가(add), 삭제(remove), 검색(contains)을 갖는다. 그 외에도 집합(합집합(addAll), 차집합(removeAll), 부분집합(containsAll), 교집합(retainAll))과, toArray(), iterator()를 갖는다.  

Collection과 Set은 위 기본적인 메서드만을 갖고 있다.  

List는
1. 특화: 기본 메서드를 indext에 특화
    - 예
        - 검색: indexOf(), lastIndexOf()
        - 집합: 인덱스 지정

2. 추가: index라서 가능한 메서드 추가
    - 예
        - 게터, 세터
        - 자르기: subList()
        - 정렬: sort

Map은  
1. 특화: 기본 메서드를 key-value에 특화
    - 예
        - 추가: key 지정 (put: 덮어쓰기. Map은 key의 중복을 허용하지 않기 때문에, 데이터를 추가할 때 add(추가)가 아닌 put(덮어쓰기)를 한다.)
        - 검색: containsKey(), containsValue()

2. 추가: key-value라서 가능한 메서드 추가
    - 예
        - 게터
            - List와 다르게 세터는 필요없다. put이 추가 + 세터 역할을 겸하기 때문이다. 
        - 뽑아내기
            - key만 뽑아내기(keySet())
            - value만 뽑아내기(values())
            - Entry로 뽑아내기(entrySet())


#### 1.1 ArrayList
- Vector는 동기화처리 되어있지만, ArrayList는 그렇지 않다.
- 참조타입 배열에 기본타입 데이터 넣을 때는 컴파일러가 오토박싱한다.
- 자리이동!이 핵심이다
    - 자리이동이란 배열에서의 자리이동을 말한다. List는 저장 순서가 있다. 이 저장 순서를 때로는 조작할 일도 필요하다. 그래서 중간 index에 데이터를 삽입하는 메서드가 있어야한다. 그런데 ArrayList는 배열이기 때문에 중간 index에 데이터를 하나 삽입하면 그 뒤에있는 데이터들은 뒤로 한 칸씩 가야한다. 배열에서는 데이터를 복사해서 이 처리를 해야한다. 따라서 배열이 아닌 LinkedList보다 성능이 느려진다.
    - 예를 들면 자리이동이 일어나기 때문에, ArrayList는 초기 크기를 지정해주는 것이 중요하다.

### 2. 인터페이스 vs 추상클래스